(** * I3: Reflekcja w dużej skali, czyli jak odbijać z rozmachem [TODO] *)

(** Chwilowo nic tu nie ma. *)

(** * [Ltac]: manipulowanie termami (TODO) *)

(* begin hide *)
(** TODO 1: (tu lista taktyk)
    - match expr
    - lazymatch expr
    - multimatch expr
    - type of term
    - eval redexpr
    - constr/uconstr/ltac
    - type_term *)
(* end hide *)

(** * Taktyki dla unifikacji (TODO) *)

(* begin hide *)
(** TODO 2: (tu lista taktyk)
    - [has_evar], [is_evar], [is_var]
    - [unify]
    - [constr_eq]
    - [instantiate]
    - [quote] *)
(* end hide *)

(** * Programowanie funkcyjne w [Ltac]u (TODO) *)

(** Wstawić tutaj przykłady podobne do tych, które opisuje Chlipala. Być
    może jakiś większy development, tzn. zaprogramować listy w dwóch
    wersjach (zwykłe i zrobione produktem i unitem). *)

(** * Big scale reflection (TODO) *)

(* begin hide *)
(** Przykłady:
    - logika boolowska, czyli legitne [btauto]
    - permutacje
    - formuły logiczne
    - upraszczanie w monoidzie *)
(* end hide *)